<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Baseball Bingo</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* General Body Styling */
        body {
            font-family: 'Inter', sans-serif;
            /* background-color: #003366;  Deep Blue - Rangers primary blue */
            background: linear-gradient(to bottom, #0055a5, #001f3f);
            color: #FFFFFF; /* White text */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 20px 10px;
            box-sizing: border-box;
            overflow-y: auto; /* Allow scrolling for smaller screens */
        }

        /* Header */
        h1 {
            color: #CC0000; /* Red - Rangers primary red */
            margin-bottom: 20px;
            font-size: 2.2em;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            border-bottom: 3px solid #FFFFFF;
            padding-bottom: 10px;
        }

        /* Bingo Grid Container */
        #bingo-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 4x4 grid */
            grid-template-rows: repeat(4, 1fr);
            gap: 8px; /* Spacing between cells */
            width: 100%;
            max-width: 400px; /* Max width for larger screens */
            background-color: #ADD8E6; /* Light blue background for the grid area */
            padding: 8px;
            border-radius: 15px; /* Rounded corners for the grid */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            margin-bottom: 25px;
            aspect-ratio: 1 / 1; /* Maintain square aspect ratio */
        }

        /* Bingo Cell Styling */
        .bingo-cell {
            background-color: #FFFFFF; /* White cell background */
            color: #003366; /* Dark blue text for cells */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 5px;
            border-radius: 10px; /* Rounded corners for cells */
            font-size: 0.9em; /* Responsive font size */
            font-weight: bold;
            cursor: pointer;
            user-select: none; /* Prevent text selection */
            transition: background-color 0.2s ease, transform 0.1s ease; /* Smooth transitions */
            border: 2px solid #CC0000; /* Red border */
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        /* Marked Cell Styling */
        .bingo-cell.marked {
            background-color: #CC0000; /* Red when marked */
            color: #FFFFFF; /* White text on marked cells */
            border-color: #003366; /* Dark blue border when marked */
            transform: scale(0.98); /* Slight shrink on mark */
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* Hover effect for cells */
        .bingo-cell:not(.marked):hover {
            background-color: #ffe6e6; /* Light red on hover */
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* Message Display */
        #message {
            font-size: 1.8em;
            font-weight: bold;
            color: #FFD700; /* Gold for emphasis */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
            margin-top: 15px;
            height: 40px; /* Reserve space to prevent layout shifts */
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease;
        }

        /* Button Container */
        .button-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            width: 100%;
            max-width: 400px;
        }

        /* Button Styling */
        .game-button {
            background-color: #CC0000; /* Red button */
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 50px; /* Pill-shaped buttons */
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex-grow: 1; /* Allow buttons to grow */
            min-width: 150px; /* Minimum width for buttons */
            margin-top: 10px;
        }

        /* Extra spacing for the Baseball Glossary button */
        #glossary-btn {
            margin-bottom: 20px;
        }

        .game-button:hover {
            background-color: #a00; /* Darker red on hover */
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .game-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        /* Specific style for reset button */
        #reset-progress-btn {
            background-color: #003366; /* Blue reset button */
        }

        #reset-progress-btn:hover {
            background-color: #002244;
        }

        /* Responsive Adjustments */
        @media (max-width: 600px) {
            h1 {
                font-size: 1.8em;
                margin-bottom: 15px;
            }
            #bingo-grid {
                gap: 6px;
                padding: 6px;
                max-width: 320px; /* Make grid slightly smaller on small phones */
            }
            .bingo-cell {
                font-size: 0.75em;
                padding: 3px;
                border-radius: 8px;
            }
            .game-button {
                padding: 10px 20px;
                font-size: 1em;
                min-width: 130px;
            }
            .button-container {
                gap: 10px;
            }
            #message {
                font-size: 1.4em;
            }
        }

        @media (max-width: 360px) {
            h1 {
                font-size: 1.6em;
            }
            #bingo-grid {
                max-width: 280px;
            }
            .bingo-cell {
                font-size: 0.7em;
            }
            .game-button {
                min-width: unset; /* Allow buttons to shrink more if needed */
                width: 100%; /* Stack buttons if too narrow */
            }
            .button-container {
                flex-direction: column;
            }
        }
</style>
<style>
    #fireworks-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 5;
    }
</style>
</head>
<body>
    <h1>⚾ Baseball Bingo ⚾</h1>

    <div id="bingo-grid">
        <!-- Bingo cells will be dynamically inserted here -->
    </div>

    <div id="message"></div>

    <div class="button-container">
        <button id="new-game-btn" class="game-button">New Game</button>
        <button id="reset-progress-btn" class="game-button">Reset Card</button>
    </div>

    <canvas id="fireworks-canvas"></canvas>
    <script>
        // Array of baseball-related terms for the bingo card
        // Baseball glossary with explanations
        const BASEBALL_GLOSSARY = {
            "100 MPH Pitch": "A pitch thrown at or above 100 miles per hour—extremely fast and rare.",
            "Spilled Drink": "When a fan accidentally spills a drink in the stands—classic stadium moment.",
            "Warning Track out": "An out caught just before the ball would’ve hit the outfield wall.",
            "Hit Foul Pole": "When a ball strikes the foul pole—it’s actually a home run!",
            "Cute Baby on Jumbotron": "A baby shown on the stadium's big screen, usually to collective 'awws'.",
            "Dot Race": "A digital or animated race between colored dots, often used as in-game entertainment.",
            "The Wave": "When fans stand and raise their arms in a coordinated ripple around the stadium.",
            "RBI Double": "A two-base hit that scores at least one run. RBI stands for 'Run Batted In'.",
            "RBI Single": "A one-base hit that scores at least one run.",
            "Mound Visit": "When a coach or player walks to the pitcher’s mound to talk with the pitcher.",
            "Strikeout Looking": "When a batter strikes out without swinging at the third strike.",
            "Walk (BB)": "A batter reaches first base after four balls are thrown by the pitcher.",
            "Stolen Base": "When a runner safely advances to the next base during a pitch.",
            "Sacrifice Fly": "A fly ball that is caught but allows a runner to score from third base.",
            "Hit by Pitch": "When the batter is struck by a pitched ball and awarded first base.",
            "Double Play": "Two outs made in one continuous play.",
            "Foul Tip Catch": "A foul ball that is tipped directly into the catcher's glove for an out.",
            "Mascot Dance": "When the team's mascot performs a dance, often for crowd entertainment.",
            "Outfield Assist": "When an outfielder throws out a runner attempting to advance.",
            "Catcher's Interference": "When the catcher hinders the batter's swing, allowing the batter to reach base.",
            "Pitching Change": "When a new pitcher replaces the current one on the mound.",
            "Manager Argument": "When the manager disputes a call with the umpire—sometimes dramatically.",
            "Fan Catches Foul Ball": "A fan in the stands catches a foul ball—sometimes barehanded!",
            "Home Run": "A hit that allows the batter to round all the bases and score.",
            "Single (1B)": "A base hit where the batter safely reaches first base.",
            "Double (2B)": "A base hit where the batter safely reaches second base.",
            "Triple (3B)": "A base hit where the batter safely reaches third base.",
            "Grand Slam": "A home run hit with the bases loaded, scoring four runs.",
            "Line Drive": "A sharply hit ball that travels low and fast in a straight line.",
            "Ground Out": "A ground ball that results in an out at first base.",
            "Fly Out": "A hit ball caught in the air by a fielder for an out.",
            "Pop Out": "A softly hit ball that goes high but not far, caught for an out.",
            "Bunt Hit": "A soft hit made by lightly tapping the ball with the bat.",
            "Tag Out": "When a runner is tagged by a fielder with the ball and called out.",
            "Run Down": "A play where a runner is caught between bases and tagged out.",
            "Triple Play": "Three outs made in one continuous defensive play—very rare.",
            "Error (E)": "A mistake by a fielder that allows a runner or batter to reach base.",
            "Balk": "An illegal motion by the pitcher that results in runners advancing a base.",
            "Wild Pitch": "A pitch so errant that the catcher can't control it, allowing runners to advance.",
            "Passed Ball": "A pitch that the catcher fails to catch, allowing runners to advance.",
            "Umpire Review": "A play that is reviewed by video replay to confirm or overturn a call.",
            "First Pitch Strike": "When the first pitch to a batter is a strike.",
            "Left on Base": "A runner who is still on base when the inning ends.",
            "Pitcher Strikes Out Side": "When the pitcher records all three outs in an inning via strikeouts.",
            "Catcher Throws Out Runner": "When the catcher throws out a baserunner attempting to steal.",
            "Broken Bat": "When a bat cracks or splits during a swing, usually on contact."
        };
        // Render glossary terms into the modal, sorted alphabetically by term
        function renderGlossary() {
            const glossaryList = document.getElementById('glossaryList') || document.getElementById('glossary-list');
            if (!glossaryList) return;
            // Sort glossary entries alphabetically by key
            const glossaryEntries = Object.entries(BASEBALL_GLOSSARY).sort(([a], [b]) => a.localeCompare(b));
            glossaryList.innerHTML = '';
            glossaryEntries.forEach(([term, definition]) => {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${term}</strong>: ${definition}`;
                glossaryList.appendChild(li);
            });
        }
        const BINGO_TERMS = [
            "Strikeout Looking", "Walk (BB)", "Stolen Base", "Sacrifice Fly",
            "Hit by Pitch", "Double Play", "Foul Tip Catch", "Mascot Dance",
            "Outfield Assist", "Catcher's Interference", "Pitching Change", "Manager Argument",
            "Fan Catches Foul Ball", "Home Run", "Single (1B)", "Double (2B)",
            "Triple (3B)", "Grand Slam", "Line Drive", "Ground Out",
            "Fly Out", "Pop Out", "Bunt Hit", "Tag Out",
            "Run Down", "Triple Play", "Error (E)", "Balk",
            "Wild Pitch", "Passed Ball", "Umpire Review", "First Pitch Strike",
            "Left on Base", "Pitcher Strikes Out Side", "Catcher Throws Out Runner", "Broken Bat",
            "100 MPH Pitch", "Spilled Drink", "Warning Track out", "Hit Foul Pole",
            "Cute Baby on Jumbotron", "Dot Race", "The Wave", "RBI Double", "RBI Single", "Mound Visit"
        ];

        const GRID_SIZE = 4; // For a 4x4 grid
        const NUM_CELLS = GRID_SIZE * GRID_SIZE;

        let currentBoard = []; // Stores the terms for the current game
        let markedCells = new Array(NUM_CELLS).fill(false); // Tracks which cells are marked

        const bingoGrid = document.getElementById('bingo-grid');
        const messageDisplay = document.getElementById('message');
        const newGameBtn = document.getElementById('new-game-btn');
        const resetProgressBtn = document.getElementById('reset-progress-btn');

        /**
         * Shuffles an array in place using the Fisher-Yates (Knuth) algorithm.
         * @param {Array} array The array to shuffle.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        /**
         * Generates a new bingo board with unique terms.
         */
        function generateNewBoard() {
            // Shuffle a copy of the terms to avoid modifying the original array
            const shuffledTerms = [...BINGO_TERMS];
            shuffleArray(shuffledTerms);

            // Select the first NUM_CELLS unique terms
            currentBoard = shuffledTerms.slice(0, NUM_CELLS);
            markedCells.fill(false); // Reset marked cells for a new game
            saveProgress(); // Save the new, unmarked board
            renderBoard();
            messageDisplay.textContent = ''; // Clear any previous bingo message
        }

        /**
         * Renders the bingo board based on currentBoard and markedCells.
         */
        function renderBoard() {
            bingoGrid.innerHTML = ''; // Clear existing cells
            currentBoard.forEach((term, index) => {
                const cell = document.createElement('div');
                cell.classList.add('bingo-cell');
                cell.textContent = term;
                cell.dataset.index = index; // Store index for easy lookup

                if (markedCells[index]) {
                    cell.classList.add('marked');
                }

                cell.addEventListener('click', handleCellClick);
                bingoGrid.appendChild(cell);
            });
        }

        /**
         * Handles the click event on a bingo cell.
         * @param {Event} event The click event.
         */
        function handleCellClick(event) {
            const index = parseInt(event.target.dataset.index);
            if (isNaN(index)) {
                console.error("Invalid cell index clicked.");
                return;
            }

            // Toggle the marked state
            markedCells[index] = !markedCells[index];
            event.target.classList.toggle('marked', markedCells[index]);

            saveProgress(); // Save progress after each click
            checkForBingo();
        }

        /**
         * Checks for a bingo (row, column, or diagonal).
         */
        function checkForBingo() {
            const rows = [];
            const cols = [];
            const diagonals = [[], []]; // [mainDiagonal, antiDiagonal]

            // Initialize rows and columns
            for (let i = 0; i < GRID_SIZE; i++) {
                rows.push([]);
                cols.push([]);
            }

            // Populate rows, columns, and diagonals
            for (let i = 0; i < NUM_CELLS; i++) {
                const row = Math.floor(i / GRID_SIZE);
                const col = i % GRID_SIZE;

                rows[row].push(markedCells[i]);
                cols[col].push(markedCells[i]);

                if (row === col) {
                    diagonals[0].push(markedCells[i]); // Main diagonal
                }
                if (row + col === GRID_SIZE - 1) {
                    diagonals[1].push(markedCells[i]); // Anti-diagonal
                }
            }

            // Check if any line (row, col, diagonal) is all true (marked)
            const isBingo = rows.some(row => row.every(cell => cell)) ||
                            cols.some(col => col.every(cell => cell)) ||
                            diagonals.some(diag => ag.every(cell => cell));

            if (isBingo) {
                messageDisplay.textContent = "HOMERUN! YOU GOT A BINGO!";
                messageDisplay.style.opacity = 1;
                startFireworks();
            } else {
                messageDisplay.textContent = "";
                messageDisplay.style.opacity = 0;
                stopFireworks();
            }
        }

        /**
         * Saves the current game state to localStorage.
         */
        function saveProgress() {
            try {
                localStorage.setItem('baseballBingoBoard', JSON.stringify(currentBoard));
                localStorage.setItem('baseballBingoMarkedCells', JSON.stringify(markedCells));
                console.log("Game progress saved.");
            } catch (e) {
                console.error("Failed to save progress to local storage:", e);
                // Optionally display a user-friendly message about storage failure
            }
        }

        /**
         * Loads the game state from localStorage.
         * @returns {boolean} True if progress was loaded, false otherwise.
         */
        function loadProgress() {
            try {
                const savedBoard = localStorage.getItem('baseballBingoBoard');
                const savedMarkedCells = localStorage.getItem('baseballBingoMarkedCells');

                if (savedBoard && savedMarkedCells) {
                    const parsedBoard = JSON.parse(savedBoard);
                    const parsedMarkedCells = JSON.parse(savedMarkedCells);

                    // Validate loaded data (e.g., correct size)
                    if (parsedBoard.length === NUM_CELLS && parsedMarkedCells.length === NUM_CELLS) {
                        currentBoard = parsedBoard;
                        markedCells = parsedMarkedCells;
                        renderBoard();
                        checkForBingo(); // Check for bingo on load in case it was achieved before
                        console.log("Game progress loaded.");
                        return true;
                    }
                }
            } catch (e) {
                console.error("Failed to load progress from local storage or data corrupted:", e);
                // Clear corrupted data to prevent persistent errors
                clearProgress();
            }
            return false;
        }

        /**
         * Clears all game progress from localStorage.
         */
        function clearProgress() {
            try {
                localStorage.removeItem('baseballBingoBoard');
                localStorage.removeItem('baseballBingoMarkedCells');
                console.log("All game progress cleared.");
            } catch (e) {
                console.error("Failed to clear progress from local storage:", e);
            }
        }

        // Event Listeners
        newGameBtn.addEventListener('click', generateNewBoard);
        resetProgressBtn.addEventListener('click', () => {
            // Confirm with the user before resetting all progress (no alert/confirm, use a simple message or visual cue if needed)
            if (confirm("Are you sure you want to reset all game progress? This cannot be undone.")) {
                 clearProgress();
                 generateNewBoard(); // Start a fresh game after clearing
            }
        });


        // Initial game setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            // Try to load saved progress, if none, start a new game
            if (!loadProgress()) {
                generateNewBoard();
            }
            renderGlossary();
            resizeCanvas();
        });

        // Glossary modal open/close logic
        document.getElementById('glossary-button')?.addEventListener('click', function() {
            document.getElementById('glossaryModal').classList.remove('hidden');
        });
        document.getElementById('closeModal')?.addEventListener('click', function() {
            document.getElementById('glossaryModal').classList.add('hidden');
        });

        // --- Fireworks Animation ---
        // Reference: https://codepen.io/ste-vg/pen/pooWQeJ (adapted for integration)
        let fireworksRunning = false;
        let animationFrameId = null;
        const canvas = document.getElementById('fireworks-canvas');
        const ctx = canvas.getContext('2d');
        let fireworks = [];
        let particles = [];

        function resizeCanvas() {
            // Set display size (css pixels).
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + "px";
            canvas.style.height = window.innerHeight + "px";
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
        }

        window.addEventListener('resize', resizeCanvas);

        class Firework {
            constructor(sx, sy, tx, ty) {
                this.x = sx;
                this.y = sy;
                this.sx = sx;
                this.sy = sy;
                this.tx = tx;
                this.ty = ty;
                this.distanceToTarget = this.calculateDistance(sx, sy, tx, ty);
                this.distanceTraveled = 0;
                this.coordinates = [];
                this.coordinateCount = 3;
                while (this.coordinateCount--) {
                    this.coordinates.push([this.x, this.y]);
                }
                this.angle = Math.atan2(ty - sy, tx - sx);
                this.speed = 2 + Math.random() * 2;
                this.acceleration = 1.05;
                this.brightness = Math.random() * 20 + 50;
                this.targetRadius = 2;
            }
            update(index) {
                this.coordinates.pop();
                this.coordinates.unshift([this.x, this.y]);
                if (this.targetRadius < 8) {
                    this.targetRadius += 0.3;
                } else {
                    this.targetRadius = 2;
                }
                let vx = Math.cos(this.angle) * this.speed;
                let vy = Math.sin(this.angle) * this.speed;
                this.x += vx;
                this.y += vy;
                this.speed *= this.acceleration;
                this.distanceTraveled = this.calculateDistance(this.sx, this.sy, this.x, this.y);
                if (this.distanceTraveled >= this.distanceToTarget) {
                    createParticles(this.tx, this.ty);
                    fireworks.splice(index, 1);
                }
            }
            draw() {
                ctx.beginPath();
                ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
                for (let i = this.coordinates.length - 1; i >= 0; i--) {
                    ctx.lineTo(this.coordinates[i][0], this.coordinates[i][1]);
                }
                ctx.strokeStyle = 'hsl(' + Math.floor(Math.random() * 360) + ', 100%, ' + this.brightness + '%)';
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(this.tx, this.ty, this.targetRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
            calculateDistance(sx, sy, tx, ty) {
                let dx = tx - sx;
                let dy = ty - sy;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.coordinates = [];
                this.coordinateCount = 5;
                while (this.coordinateCount--) {
                    this.coordinates.push([this.x, this.y]);
                }
                this.angle = Math.random() * Math.PI * 2;
                this.speed = Math.random() * 10 + 2;
                this.friction = 0.95;
                this.gravity = 0.7;
                this.hue = Math.floor(Math.random() * 360);
                this.brightness = Math.random() * 40 + 50;
                this.alpha = 1;
                this.decay = Math.random() * 0.015 + 0.015;
            }
            update(index) {
                this.coordinates.pop();
                this.coordinates.unshift([this.x, this.y]);
                this.speed *= this.friction;
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed + this.gravity;
                this.alpha -= this.decay;
                if (this.alpha <= 0.01) {
                    particles.splice(index, 1);
                }
            }
            draw() {
                ctx.beginPath();
                ctx.moveTo(this.coordinates[this.coordinates.length - 1][0], this.coordinates[this.coordinates.length - 1][1]);
                for (let i = this.coordinates.length - 1; i >= 0; i--) {
                    ctx.lineTo(this.coordinates[i][0], this.coordinates[i][1]);
                }
                ctx.strokeStyle = 'hsla(' + this.hue + ', 100%, ' + this.brightness + '%, ' + this.alpha + ')';
                ctx.stroke();
            }
        }

        function createParticles(x, y) {
            let particleCount = 30 + Math.floor(Math.random() * 20);
            while (particleCount--) {
                particles.push(new Particle(x, y));
            }
        }

        function loop() {
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'lighter';

            let i = fireworks.length;
            while (i--) {
                fireworks[i].draw();
                fireworks[i].update(i);
            }
            let j = particles.length;
            while (j--) {
                particles[j].draw();
                particles[j].update(j);
            }
            // Randomly launch fireworks if running
            if (fireworksRunning && Math.random() < 0.08) {
                let sx = window.innerWidth / 2;
                let sy = window.innerHeight;
                let tx = Math.random() * window.innerWidth * 0.8 + window.innerWidth * 0.1;
                let ty = Math.random() * window.innerHeight * 0.4 + window.innerHeight * 0.1;
                fireworks.push(new Firework(sx, sy, tx, ty));
            }
            if (fireworksRunning || fireworks.length > 0 || particles.length > 0) {
                animationFrameId = requestAnimationFrame(loop);
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                animationFrameId = null;
            }
        }

        function startFireworks() {
            if (fireworksRunning) return;
            fireworksRunning = true;
            canvas.style.display = 'block';
            loop();
        }
        function stopFireworks() {
            fireworksRunning = false;
            // Let any remaining fireworks/particles finish animating, but don't launch new ones.
        }
    </script>
</body>
<footer style="padding: 1rem; margin-top: 2rem; text-align: center; font-size: 0.9rem;">
  Created for the betterment of your life by <a href="https://NewJourneyDesign.co" target="_blank" style="color: white; text-decoration: underline;">NewJourneyDesign.co</a> &copy; 2025
</footer>
</html>
</body>
</html>